<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>More complex example - Zinc v0.1.5</title>
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="The official Zinc book">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "../";
            var default_theme = "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="affix"><a href="../index.html">Introduction</a></li><li><a href="../01-design-background.html"><strong aria-hidden="true">1.</strong> Design background</a></li><li><a href="../02-getting-started/01-first-circuit.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li><a href="../02-getting-started/02-more-complex-example.html" class="active"><strong aria-hidden="true">2.1.</strong> More complex example</a></li></ol></li><li><a href="../03-basic-concepts/00-overview.html"><strong aria-hidden="true">3.</strong> Basic concepts</a></li><li><ol class="section"><li><a href="../03-basic-concepts/01-input-output.html"><strong aria-hidden="true">3.1.</strong> Input and output</a></li><li><a href="../03-basic-concepts/02-builtin-functions.html"><strong aria-hidden="true">3.2.</strong> Built-in functions</a></li><li><a href="../03-basic-concepts/03-standard-library.html"><strong aria-hidden="true">3.3.</strong> Standard library</a></li></ol></li><li><a href="../04-variables-and-types/00-overview.html"><strong aria-hidden="true">4.</strong> Variables and types</a></li><li><ol class="section"><li><a href="../04-variables-and-types/01-variables.html"><strong aria-hidden="true">4.1.</strong> Variables</a></li><li><a href="../04-variables-and-types/02-types/00-overview.html"><strong aria-hidden="true">4.2.</strong> Types</a></li><li><ol class="section"><li><a href="../04-variables-and-types/02-types/01-scalar.html"><strong aria-hidden="true">4.2.1.</strong> Scalar</a></li><li><a href="../04-variables-and-types/02-types/02-arrays.html"><strong aria-hidden="true">4.2.2.</strong> Arrays</a></li><li><a href="../04-variables-and-types/02-types/03-tuples.html"><strong aria-hidden="true">4.2.3.</strong> Tuples</a></li><li><a href="../04-variables-and-types/02-types/04-structures.html"><strong aria-hidden="true">4.2.4.</strong> Structures</a></li><li><a href="../04-variables-and-types/02-types/05-enumerations.html"><strong aria-hidden="true">4.2.5.</strong> Enumerations</a></li><li><a href="../04-variables-and-types/02-types/06-strings.html"><strong aria-hidden="true">4.2.6.</strong> Strings</a></li><li><a href="../04-variables-and-types/02-types/07-casting-and-conversions.html"><strong aria-hidden="true">4.2.7.</strong> Casting and conversions</a></li></ol></li><li><a href="../04-variables-and-types/03-functions.html"><strong aria-hidden="true">4.3.</strong> Functions</a></li></ol></li><li><a href="../05-operators/00-overview.html"><strong aria-hidden="true">5.</strong> Operators</a></li><li><ol class="section"><li><a href="../05-operators/01-arithmetic.html"><strong aria-hidden="true">5.1.</strong> Arithmetic</a></li><li><a href="../05-operators/02-bitwise.html"><strong aria-hidden="true">5.2.</strong> Bitwise</a></li><li><a href="../05-operators/03-comparison.html"><strong aria-hidden="true">5.3.</strong> Comparison</a></li><li><a href="../05-operators/04-logical.html"><strong aria-hidden="true">5.4.</strong> Logical</a></li><li><a href="../05-operators/05-casting.html"><strong aria-hidden="true">5.5.</strong> Casting</a></li><li><a href="../05-operators/06-access.html"><strong aria-hidden="true">5.6.</strong> Access</a></li><li><a href="../05-operators/07-range.html"><strong aria-hidden="true">5.7.</strong> Range</a></li><li><a href="../05-operators/08-assignment.html"><strong aria-hidden="true">5.8.</strong> Assignment</a></li></ol></li><li><a href="../06-expressions/00-overview.html"><strong aria-hidden="true">6.</strong> Expressions</a></li><li><ol class="section"><li><a href="../06-expressions/01-literals.html"><strong aria-hidden="true">6.1.</strong> Literals</a></li><li><a href="../06-expressions/02-blocks.html"><strong aria-hidden="true">6.2.</strong> Blocks</a></li><li><a href="../06-expressions/03-conditionals.html"><strong aria-hidden="true">6.3.</strong> Conditionals</a></li></ol></li><li><a href="../07-statements/00-overview.html"><strong aria-hidden="true">7.</strong> Statements</a></li><li><ol class="section"><li><a href="../07-statements/01-declaration.html"><strong aria-hidden="true">7.1.</strong> Declaration</a></li><li><a href="../07-statements/02-expression.html"><strong aria-hidden="true">7.2.</strong> Expression</a></li><li><a href="../07-statements/03-control.html"><strong aria-hidden="true">7.3.</strong> Control</a></li></ol></li><li><a href="../08-virtual-machine/00-overview.html"><strong aria-hidden="true">8.</strong> Virtual machine</a></li><li><a href="../09-zargo-circuit-manager/00-overview.html"><strong aria-hidden="true">9.</strong> Zargo circuit manager</a></li><li><a href="../10-schnorr-signature-tool/00-overview.html"><strong aria-hidden="true">10.</strong> Schnorr signature tool</a></li><li><a href="../appendix/_overview.html"><strong aria-hidden="true">11.</strong> Appendix</a></li><li><ol class="section"><li><a href="../appendix/A-grammar-lexical.html"><strong aria-hidden="true">11.1.</strong> A - Lexical grammar</a></li><li><a href="../appendix/B-grammar-syntax.html"><strong aria-hidden="true">11.2.</strong> B - Syntax grammar</a></li><li><a href="../appendix/C-keywords.html"><strong aria-hidden="true">11.3.</strong> C - Keywords</a></li><li><a href="../appendix/D-built-in-functions.html"><strong aria-hidden="true">11.4.</strong> D - Built-in functions</a></li><li><a href="../appendix/E-standard-library.html"><strong aria-hidden="true">11.5.</strong> E - Standard library</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Zinc v0.1.5</h1>

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1><a class="header" href="#merkle-proof" id="merkle-proof">Merkle proof</a></h1>
<p>In this chapter, we will implement a circuit able to validate the Merkle tree
root hash.</p>
<p>At this stage of reading the book, you may be unfamiliar with some language
concepts. So, if you struggle to understand some examples, you are welcome to
read the rest of the book first, and then come back here.</p>
<p>Our circuit will accept the tree node path, address, and the balance available
as the secret witness data. The public data will be the Merkle tree root hash.</p>
<h2><a class="header" href="#creating-a-new-project" id="creating-a-new-project">Creating a new project</a></h2>
<p>Let's create a new circuit called <code>merkle-proof</code>:</p>
<pre><code class="language-bash">zargo new merkle-proof
cd merkle-proof
</code></pre>
<p>Now, you can open the project in your favorite IDE and go to <code>src/main.zn</code>,
where we are going to start writing the circuit code.</p>
<h2><a class="header" href="#defining-types" id="defining-types">Defining types</a></h2>
<p>Let's start by defining the secret witness data arguments and the public data
return type.</p>
<pre><pre class="playpen"><code class="language-rust">struct PublicInput {
    root_hash: [bool; 256];
}

fn main(
    address: [bool; 10], // the node address in the merkle tree
    balance: field, // the balance stored in the node
    merkle_path: [[bool; 256]; 10] // the hash path to the node
) -&gt; PublicInput {
    // ...
}
</code></pre></pre>
<p>As you can see, some complex types are used in several places of our code, so
it is very convenient to create an alias for such type.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
type Sha256Digest = [bool; 256];
#}</code></pre></pre>
<h2><a class="header" href="#creating-functions" id="creating-functions">Creating functions</a></h2>
<p>Now, we will write a function to calculate the <code>sha256</code> hash of
our balance. We need it to verify the balance stored within the leaf node at our
Merkle tree path.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}
#}</code></pre></pre>
<p>The function accepts <code>balance</code> we passed as secret witness data, converts it
into a bit array of length 254 (elliptic curve field length), and pads the
array with 2 extra zero bits, since we are going to pass 256 bit vector to the
<code>sha256</code> function.</p>
<p>We have also used here three functions from the Zinc <a href="../appendix/E-standard-library.html">standard library</a>
from three different modules. The <code>std::crypto::sha256</code>-like paths might seem a
bit verbose, but we will solve this problem later.</p>
<p>At this stage, this is how our code looks like:</p>
<pre><pre class="playpen"><code class="language-rust">type Sha256Digest = [bool; 256];

struct PublicInput {
    root_hash: Sha256Digest,
}

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}

fn main(
    address: [bool; 10], // the node address in the merkle tree
    balance: field, // the balance stored in the node
    merkle_path: [Sha256Digest; 10] // the hash path to the node
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance);

    // ...
}
</code></pre></pre>
<p>Now, we need a function to calculate a tree node hash:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512]; // [bool; 512]

    // Casting to u16 is needed to make the range types equal,
    // since 0 will be inferred as u8, and 256 - as u16.
    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    std::crypto::sha256(data) // [bool; 256] a.k.a. Sha256Digest
}
#}</code></pre></pre>
<p>The Zinc standard library does not support array concatenation yet, so, for now,
we will do it by hand, allocating an array to contain two leaf node digests,
then put the digests together and hash them with <code>std::crypto::sha256</code>.</p>
<p>Finally, let's define a function to calculate the hash of the whole tree:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash; // Sha256Digest

    // Traverse the tree from the left node to the root node
    for i in 0..10 {
        // Multiple variables binding is not supported yet,
        // so we going to store leaves as an array of two digests.
        // If address[i] is 0, we are in the left node, otherwise,
        // we are in the right node.
        let left_and_right = if address[i] {
            [current, merkle_path[i]] // [Sha256Digest; 2]
        } else {
            [merkle_path[i], current] // [Sha256Digest; 2]
        };

        // remember the current node hash
        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    // return the root node hash
    current
}
#}</code></pre></pre>
<p>Congratulations! Now we have a working circuit able to verify the Merkle proof!</p>
<pre><pre class="playpen"><code class="language-rust">// main.zn

type Sha256Digest = [bool; 256];

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance); // [bool; 254]
    let bits_padded = std::array::pad(bits, 256, false); // [bool; 256]
    std::crypto::sha256(bits_padded) // [bool; 256] a.k.a. Sha256Digest
}

fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512]; // [bool; 512]

    // Casting to u16 is needed to make the range types equal,
    // since 0 will be inferred as u8, and 256 - as u16.
    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    std::crypto::sha256(data) // [bool; 256] a.k.a. Sha256Digest
}

fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash; // Sha256Digest

    // Traverse the tree from the left node to the root node
    for i in 0..10 {
        // Multiple variables binding is not supported yet,
        // so we going to store leaves as an array of two digests.
        // If address[i] is 0, we are in the left node, otherwise,
        // we are in the right node.
        let left_and_right = if address[i] {
            [current, merkle_path[i]] // [Sha256Digest; 2]
        } else {
            [merkle_path[i], current] // [Sha256Digest; 2]
        };

        // remember the current node hash
        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    // return the root node hash
    current
}

struct PublicInput {
    root_hash: Sha256Digest,
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [Sha256Digest; 10]
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance);

    let root_hash = restore_root_hash(
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre></pre>
<h2><a class="header" href="#defining-a-module" id="defining-a-module">Defining a module</a></h2>
<p>Our <code>main.zn</code> module has got a little overpopulated by now, so let's move our
functions to another one called <code>merkle</code>. At first, create a file called <code>merkle.zn</code>
in the <code>src</code> directory besides <code>main.zn</code>. Then, move everything above the
<code>PublicInput</code> definition to that file. Our <code>main.zn</code> will now look like this:</p>
<pre><pre class="playpen"><code class="language-rust">struct PublicInput {
    root_hash: Sha256Digest, // undeclared `Sha256Digest`
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [Sha256Digest; 10] // undeclared `Sha256Digest`
) -&gt; PublicInput {
    let leaf_hash = balance_hash(balance); // undeclared `balance_hash`

    let root_hash = restore_root_hash( // undeclared `restore_root_hash`
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre></pre>
<p>This code will not compile, as we have several items undeclared now! Let's
define our <code>merkle</code> module and resolve the function paths:</p>
<pre><pre class="playpen"><code class="language-rust">mod merkle; // defined a module

struct PublicInput {
    root_hash: merkle::Sha256Digest, // use a type declaration from `merkle`
}

fn main(
    address: [bool; 10],
    balance: field,
    merkle_path: [merkle::Sha256Digest; 10] // use a type declaration from `merkle`
) -&gt; PublicInput {
    let leaf_hash = merkle::balance_hash(balance); // call a function from `merkle`

    // call a function from `merkle`
    let root_hash = merkle::restore_root_hash(
        leaf_hash,
        address,
        merkle_path,
    );

    PublicInput {
        root_hash: root_hash,
    }
}
</code></pre></pre>
<p>Perfect! Now all our functions and types are defined. By the way, let's have a
glance at our <code>merkle</code> module, where you can find another improvement!</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::crypto::sha256; // an import

type Sha256Digest = [bool; 256];

fn balance_hash(balance: field) -&gt; Sha256Digest {
    let bits = std::convert::to_bits(balance);
    let bits_padded = std::array::pad(bits, 256, false);
    sha256(bits_padded)
}

fn merkle_node_hash(left: Sha256Digest, right: Sha256Digest) -&gt; Sha256Digest {
    let mut data = [false; 512];

    for i in 0 as u16..256 {
        data[i] = left[i];
        data[256 + i] = right[i];
    }

    sha256(data)
}

fn restore_root_hash(
    leaf_hash: Sha256Digest,
    address: [bool; 10],
    merkle_path: [Sha256Digest; 10],
) -&gt; Sha256Digest
{
    let mut current = leaf_hash;

    for i in 0..10 {
        let left_and_right = if address[i] {
            [current, merkle_path[i]]
        } else {
            [merkle_path[i], current]
        };

        current = merkle_node_hash(left_and_right[0], left_and_right[1]);
    }

    current
}
#}</code></pre></pre>
<p>You may notice a <code>use</code> statement at the first line of code. It is an import statement
which is designed to prevent using long repeated paths in our code. As you can see,
now we call the standard library function like this <code>sha256(data)</code>, but not like
that <code>std::crypto::sha256(data)</code>.</p>
<h2><a class="header" href="#finalizing" id="finalizing">Finalizing</a></h2>
<p>Congratulations, you are an experienced Zinc developer!
Now, you may build the circuit, generate and verify a proof, like it was
explained in the <a href="./01-first-circuit.html">previous chapter</a>,
and move on to reading the rest of the book!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../02-getting-started/01-first-circuit.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../03-basic-concepts/00-overview.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../02-getting-started/01-first-circuit.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../03-basic-concepts/00-overview.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
